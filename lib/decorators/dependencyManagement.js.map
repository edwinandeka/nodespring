{"version":3,"sources":["../../src/decorators/dependencyManagement.js"],"names":["Inject","Implements","Interface","PostInject","global","implContext","Scope","SINGLETON","PROTOTYPE","typeToInject","nodeSpringUtil","isClass","NodeSpringException","basePackagePath","path","dirname","getStack","replace","ModuleContainer","appDir","target","property","descriptor","packagePath","constructor","name","writable","targetName","preConfiguredImpl","implConfig","basename","error","moduleType","TypeError","addDependency","type","scope","interfaceName","interfacePackagePath","addImplementation","interfaceBase","addInterface","MockedInterface","Abstract","Object","defineProperty","value","configurable","interfaceMethods","getOwnPropertyNames","prototype","filter","methodName","forEach","method","getInstance","modulesContainer","addPostInjectMethod"],"mappings":"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","file":"dependencyManagement.js","sourcesContent":["/**\n * Dependency Management\n * @author calbertts\n */\n\nimport ModuleContainer from '../core/ModuleContainer'\nimport path from 'path'\nimport Abstract from '../core/Abstract'\nimport nodeSpringUtil from '../core/nodeSpringUtil'\nimport NodeSpringException from '../exceptions/NodeSpringException'\nimport util from 'util'\n\n\nglobal.implContext = null\n\n\n/**\n * Enumeration to specify the scope type for implementations\n * @type {{SINGLETON: string, PROTOTYPE: string}}\n */\nexport var Scope = {\n  SINGLETON: 'singleton',\n  PROTOTYPE: 'prototype'\n}\n\n\n/**\n * Decorator to inject a dependency using an interface\n * @param typeToInject\n * @returns {Function}\n * @constructor\n */\nexport function Inject(typeToInject) {\n  if(!typeToInject || !nodeSpringUtil.isClass(typeToInject)) {\n    throw new NodeSpringException('@Inject expects an Interface but an ' + typeToInject + ' was received.', this, 2)\n  }\n\n  let basePackagePath = path.dirname(nodeSpringUtil.getStack().replace(ModuleContainer.appDir, '').replace('.js', ''))\n\n  return (target, property, descriptor) => {\n    let packagePath = basePackagePath + '/' + target.constructor.name\n\n    descriptor.writable = true\n\n    let targetName = global.implContext ? global.implContext.packagePath : packagePath\n    let preConfiguredImpl = ModuleContainer.implConfig[targetName]\n\n    //nodeSpringUtil.debug('inject:', targetName)\n\n    if(preConfiguredImpl) {\n      if(path.basename(packagePath) !== path.basename(preConfiguredImpl)) {\n        nodeSpringUtil.error('Ignored implementation from @Inject ' + packagePath)\n        return\n      }\n    }\n\n    if(typeToInject.moduleType === 'controller') {\n      throw new TypeError('You cannot inject a Controller as a dependency, please take a look on ' + targetName)\n    }\n\n    ModuleContainer.addDependency(targetName, property, typeToInject)\n  }\n}\n\n\n/**\n * Decorator to specify when a class implements a specific interface\n * @param type\n * @param scope\n * @returns {Function}\n * @constructor\n */\nexport function Implements(type, scope = Scope.SINGLETON) {\n  if(!type || !nodeSpringUtil.isClass(type)) {\n    throw new NodeSpringException('@Implements expects a Class but an ' + type + ' was received.', this, 2)\n  }\n\n  if(scope !== Scope.SINGLETON && scope !== Scope.PROTOTYPE) {\n    throw new NodeSpringException('Invalid Scope for ' + type.name + ', ' + scope + ' was received', this, 2)\n  }\n\n  global.implContext = type\n\n  return (target, property, descriptor) => {\n    target.scope = scope\n    target.interfaceName = type.name\n    target.interfacePackagePath = type.packagePath\n    target.moduleType = 'implementation'\n\n    global.implContext = null\n\n    let preConfiguredImpl = ModuleContainer.implConfig[type.packagePath]\n\n    if(preConfiguredImpl) {\n      if(target.name !== path.basename(preConfiguredImpl)) {\n        nodeSpringUtil.error('Ignored implementation from @Implements ' + target.name)\n        return\n      }\n    }\n\n    ModuleContainer.addImplementation(type, target)\n  }\n}\n\n\n/**\n * Decorator to specify a class is an interface\n * @param interfaceBase\n * @returns {MockedInterface}\n * @constructor\n */\nexport function Interface(interfaceBase) {\n  if(!interfaceBase || !nodeSpringUtil.isClass(interfaceBase)) {\n    throw new NodeSpringException('@Interface expects a Class but an ' + interfaceBase + ' was received.', this, 2)\n  }\n\n  let basePackagePath = path.dirname(nodeSpringUtil.getStack().replace(ModuleContainer.appDir, '').replace('.js', ''))\n  let packagePath = basePackagePath + '/' + interfaceBase.name\n\n  ModuleContainer.addInterface(packagePath)\n\n  class MockedInterface extends Abstract {\n    static moduleType = 'interface'\n    static packagePath = packagePath\n\n    constructor() {\n      super()\n    }\n  }\n\n  Object.defineProperty(MockedInterface, 'name', {\n    value: interfaceBase.name,\n    configurable: true\n  })\n\n  let interfaceMethods = Object.getOwnPropertyNames(interfaceBase.prototype)\n\n  interfaceMethods.filter((methodName) => {\n    return methodName !== 'constructor'\n  }).forEach((method) => {\n    if(method === 'getInstance')\n      throw new NodeSpringException('getInstance(...) is a reserved method for Interfaces, try with other name on ' + interfaceBase.name, this, 2)\n\n    MockedInterface.prototype[method] = interfaceBase.prototype[method]\n  })\n\n  MockedInterface.getInstance = () => {\n    return modulesContainer[packagePath].getInstance()\n  }\n\n  return MockedInterface\n}\n\n\n/**\n * Decorator to indicate a method which must be called after all dependencies are injected\n * @param target\n * @param property\n * @param descriptor\n * @constructor\n */\nexport function PostInject(target, property, descriptor) {\n  let basePackagePath = path.dirname(nodeSpringUtil.getStack().replace(ModuleContainer.appDir, '').replace('.js', ''))\n  let packagePath = basePackagePath + '/' + target.constructor.name\n  let targetName = global.implContext ? global.implContext.packagePath : packagePath\n\n  ModuleContainer.addPostInjectMethod(targetName, property)\n}\n"]}